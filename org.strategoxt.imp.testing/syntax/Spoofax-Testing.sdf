%% Grammar for the Spoofax-Testing language
%% By default, based on an example "entities" syntax
module Spoofax-Testing

imports Common
imports Spoofax-Testing-String-Quotation
imports languages/aterm/syntax/ATerms
imports RegExp
imports Stratego-Sugar [ Ws -> LAYOUT => IGNORE -> NOTHING ]

exports
  context-free start-symbols TestSuite

exports
  sorts TestSuite TopSort Test Input Result
  context-free syntax
    Header* TestDecl*   -> TestSuite {cons("testsuite")}
    ID                  -> TestSuite {cons("EmptyFile"), recover}
    "testsuite" ID      -> Header {cons("Name"), deprecated("Use 'module' instead")}
    "module" ID         -> Header {cons("Name")}
    "package" ID        -> Header {cons("Package")}
    "options"           -> Header {cons("Options"), deprecated}
    "topsort" ID        -> Header {cons("TopSort"), deprecated("Use 'start symbol' instead")}
    "start" "symbol" ID -> Header {cons("TopSort")}
    "language" ID       -> Header {cons("Language")}

    ParseTest    -> TestDecl
    StrategoTest -> TestDecl
    VarDecl      -> TestDecl

  %% The description syntax is very ambiguous if comments are allowed around it. So, we forbid comments.
  syntax
    "setup" <Space-LEX> <Description-CF> <LAYOUT?-CF> <Input-CF> -> <ParseTest-CF> {cons("Setup")}
    "setup" <Space-LEX> <Description-CF>                         -> <ParseTest-CF> {cons("SetupEmpty")}
    
    "test" <Space-LEX> <Description-CF> <LAYOUT?-CF> <Input-CF> <LAYOUT?-CF> <Result*-CF> -> <ParseTest-CF> {cons("Test")}
    "test" <Space-LEX> <Description-CF> <LAYOUT?-CF> <TestStrategy-CF> <LAYOUT?-CF> <StrategoResult-CF>
      -> <StrategoTest-CF> {cons("TestStratego")}
    "test" <Space-LEX> <Description-CF> -> <ParseTest-CF> {cons("TestEmpty")}

  context-free syntax
    ID "=" ATerm -> VarDecl {cons("VarDecl")}

  context-free syntax
               -> StrategoResult {cons("StrategySuccess")}
    "succeeds" -> StrategoResult {cons("StrategySuccess")}
    "fails"    -> StrategoResult {cons("StrategyFails")}
    "=>" ATerm -> StrategoResult {cons("StrategyEquals")}
    "->" ATerm -> StrategoResult {cons("StrategyEquals"), deprecated("Use => instead of ->")}
    Strategy   -> TestStrategy

    String                               -> TestStrategy {reject}
    "[" {Strategy ","}* "]"              -> TestStrategy {reject}
    "[" {Strategy ","}* "|" Strategy "]" -> TestStrategy {reject}
    Strategy "=>" Term                   -> TestStrategy {reject}
    "succeeds"                           -> Term {reject}
    "fails"                              -> Term {reject}

  lexical syntax
    [\ ]+ -> Space

  lexical restrictions
    Space -/- [\ ]

  context-free syntax
    
    "->" "file" PathName -> Result {cons("file"),    deprecated("Use => instead of ->")}
    "->" ATerm           -> Result {cons("pattern"), deprecated("Use => instead of ->")}
    
    "=>" "file" PathName -> Result {cons("file")}
    "=>" ATerm           -> Result {cons("pattern")}

    "fails"              -> Result {cons("Fails")}
    "fails" "parsing"    -> Result {cons("FailsParsing")}
    "succeeds"           -> Result {cons("Success")}
    "succeeds" "parsing" -> Result {cons("SuccessParsing")}

    "file" PathName -> Input {cons("file")}

    INT "error"       -> Result    {cons("Error")}
    INT "errors"      -> Result    {cons("Errors")}
    
    INT "warning"     -> Result    {cons("Warning")}
    INT "warnings"    -> Result    {cons("Warnings")}
    
    "resolves" ResolveID                       -> Result {cons("Resolves")}
    "resolves" ResolveID "to" ResolveID        -> Result {cons("ResolvesTo")}
    "completes" CompletionID                   -> Result {cons("Completes")}
    "completes" CompletionID "to" CompletionID -> Result {cons("CompletesTo")}
    "builds" ID                                -> Result {cons("Builds")}
    "builds" ID "to" ATerm                     -> Result {cons("BuildsTo")}
    "builds" ID "to" "file" PathName           -> Result {cons("BuildsFile")}
    %% TODO: hover help, refactoring, run, builds to with an 'Output' concrete syntax tree
    
    RegexExp          -> Constraint
    
    ID "#" INT -> ResolveID {cons("Numbered")}
    ID         -> ResolveID {cons("Unnumbered")}
    
    ID "#" INT -> CompletionID {cons("Numbered")}
    ID         -> CompletionID {cons("Unchecked")}
    
    %% Handle a couple of lousy recoveries
    "test"  -> ID    {reject}
    "setup" -> ID    {reject}
    "test"  -> ATerm {reject}
    "setup" -> ATerm {reject}
            -> "resolves" {recover, reject}
            -> "=>" {recover, reject}
            -> "->" {recover, reject}
           
  %% test Primitive refactoring test
  %% [[ module x entity X {} ]] refactoring rename at X input Y =>
  %% [[ module x entity Y {} ]]
 
context-free syntax

  %% UNDONE: ATerm syntax patches that should be in our ATerm.def already

  %% allow unquoted upper case AFuns
  %% lexical syntax
  %%   "" -> IdCon {cons("empty")}

  %% empty is ok, but cannot be a complete ATerm.
  %% context-free syntax
  %%   ""-> ATerm {reject}

  %% allow function applications without arguments
  %%context-free syntax
  %%  fun:AFun "(" ")" -> ATerm {cons("fun")}
  
    "_"                  -> ATerm  {cons("wildcard")}
    "..."                -> { ATerm ","}+ {cons("wildcardvar")}

  context-free syntax
    StringQuotation -> Input
    
  sorts
  syntax
      
  %% Too close to Stratego
  %%  <DQuote1-LEX> <InputChars1-LEX> <DQuote1-LEX> -> <Input-CF> {cons("string")}
    <DQuote2-LEX> <InputChars2-LEX> <DQuote2-LEX> -> <Input-CF> {cons("string")}
    <DQuote3-LEX> <InputChars3-LEX> <DQuote3-LEX> -> <Input-CF> {cons("string")}
    <DQuote4-LEX> <InputChars4-LEX> <DQuote4-LEX> -> <Input-CF> {cons("string")}

  %% Too close to Stratego
  %%<Bracket1-LEX> <InputChars21-LEX> <CloseBracket1-LEX> -> <Input-CF> {cons("string")}
  
    <Bracket2-LEX> <InputChars22-LEX> <CloseBracket2-LEX> -> <Input-CF> {cons("string")}
    <Bracket3-LEX> <InputChars23-LEX> <CloseBracket3-LEX> -> <Input-CF> {cons("string")}
    <Bracket4-LEX> <InputChars24-LEX> <CloseBracket4-LEX> -> <Input-CF> {cons("string")}

  sorts Name Description
  context-free syntax
    EOLString -> Description {cons("description")}

  sorts Sort EOLString
  lexical syntax

    (~[\n\[\"]|EOLQuote1|EOLQuote2)* -> EOLString
    [\"]                             -> EOLQuote1
    [\[]                             -> EOLQuote2

  sorts
    InputChars1 InputChars2 InputChars3 InputChars4
    DQuote1 DQuote2 DQuote3
    InputChars21 InputChars22 InputChars23 InputChars24
    Bracket1 Bracket2 Bracket3

  lexical syntax
    ~[\"]* -> InputChars1
    (~[\"]  | DQuote1)*                      -> InputChars2
    (~[\"]  | DQuote1 | DQuote2)*            -> InputChars3
    (~[\"]  | DQuote1 | DQuote2 | DQuote3 )* -> InputChars4

    "\""       -> DQuote1
    "\"\""     -> DQuote2
    "\"\"\""   -> DQuote3
    "\"\"\"\"" -> DQuote4

    ~[\[]* -> InputChars21
    (~[\[]  | Bracket1)*                        -> InputChars22
    (~[\[]  | Bracket1 | Bracket2)*             -> InputChars23
    (~[\[]  | Bracket1 | Bracket2 | Bracket3 )* -> InputChars24

    "["    -> Bracket1
    "[["   -> Bracket2
    "[[["  -> Bracket3
    "[[[[" -> Bracket4

    "]"    -> CloseBracket1
    "]]"   -> CloseBracket2
    "]]]"  -> CloseBracket3
    "]]]]" -> CloseBracket4

  sorts PathName
  lexical syntax
    [A-Za-z0-9\-\_\.\\\/]+ -> PathName

  lexical restrictions
    EOLString -/- ~[\n\[\"]
    EOLQuote1 -/- ~[\"]
    EOLQuote2 -/- ~[\[]

    DQuote1   -/- [\"]
    DQuote2   -/- [\"]
    DQuote3   -/- [\"]

    Bracket1   -/- [\[]
    Bracket2   -/- [\[]
    Bracket3   -/- [\[]

  sorts ShortCom LongCom CommChar Asterisk Eof
  lexical syntax
    "//" ~[\n]* ([\n] | Eof) -> ShortCom
    "/*" CommChar* "*/"      -> LongCom
                             -> Eof
    
    ~[\*]      -> CommChar

    "*"        -> Asterisk
    Asterisk   -> CommChar

  lexical restrictions
    Asterisk -/- [\/]

  lexical syntax
    ShortCom    -> LAYOUT
    LongCom     -> LAYOUT

