module check-resolve

imports
  libstratego-lib
  libstratego-aterm
  include/Spoofax-Testing
  lib/editor-common.generated
  aterm-eq
  spoofax_testing
  check

rules

  check-expectation(|ast, selections, messages) :
    ResolvesTo(_, _) -> $[No reference resolving defined for [<Language>]]
    where
      spt-get-reference-resolvers => []
  
  check-error:
    Test(_, _, input{a*}, expectations) -> error*
    where
      !a* => [ast | selections];
      reference* := <collect-all(?Numbered(_) + ?Unnumbered(), conc)> expectations;
      error*     := <filter(check-selection(|selections))> reference*
  
  check-selection(|selections):
    Numbered(n) -> (n, $[Identifier not found in input])
    where
      not(resolve-selection(|selections))
  
  resolve-selection(|selections):
    Numbered(n) -> selection
    where
      n'        := <string-to-int> n;
      selection := <index(|n')> selections
  
  resolve-selection(|selections):
    Unnumbered() -> <resolve-selection(|selections)> Numbered("1")
  
  check-expectation(|ast, selections, messages) :
    Resolves(x) -> <check-expectation(|ast, selections, messages)> ResolvesTo(x, wildcard())

  check-expectation(|ast, selections, messages) :
    ResolvesTo(from, to) -> error
    where
      from' := <resolve-selection(|selections)> from;
      to'   := <resolve-selection(|selections)> to
    with
      from''    := <get-service-input-term> from';
      resolvers := <spt-get-reference-resolvers>;
      results   := <map(execute-service(|from''))> resolvers
    where
      switch !results
        case one(is-successful-resolver(|to')): fail
        case one(?Some(t)):  error := $[Unexpected result: [<write-to-string> t]]
        case one(?Error(m)): error := $[Unexpected error: [m]]
        case one(?Fail(m)):  error := $[Unexpected error: [m]]
        otherwise: with(fail)
      end
  
  is-successful-resolver(|expected):
    Some(result) -> <id>
    where
      !expected => wildcard()
    <+
      oncetd(origin-equal(|expected))
